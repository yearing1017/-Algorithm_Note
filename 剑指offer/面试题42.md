### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

#### 题目描述

- 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

#### 示例

> 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

#### 解法：动态规划

- 状态定义： 设动态规划列表 dp ，**dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和**。
- 为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 **连续子数组** 要求。

- 转移方程： **若dp[i−1]≤0 ，说明 dp[i−1] 对dp[i] 产生负贡献，即dp[i-1] + nums[i] 还不如nums[i]本身大**。
  - 当 dp[i−1]>0 时：执行 dp[i] = dp[i-1] + nums[i] ；
  - 当 dp[i−1]≤0 时：执行 dp[i] = nums[i]；

- 初始状态： dp[0] = nums[0]，即以 nums[0]结尾的连续子数组最大和为 nums[0]。


- 空间复杂度降低：
  - 由于dp[i] 只与 dp[i−1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums 上修改即可。
  - 由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。
- 复杂度分析：
  - 时间复杂度 O(N) ： 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。
  - 空间复杂度 O(1)： 使用常数大小的额外空间。

- 代码1：直接在元素组上修改

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            nums[i] += max(nums[i - 1], 0)
        return max(nums)
```

- 代码2：**有些题目可能会要求不更改原数组，新增两个变量取存储最大的dp元素，空间复杂度仍为O(1)**

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_val = nums[0]
        former = 0
        cur = 0
        for i in range(len(nums)):
            cur = nums[i]
            if former>0: cur += former
            if cur > max_val:
                max_val = cur
            former = cur
        return max_val
```

