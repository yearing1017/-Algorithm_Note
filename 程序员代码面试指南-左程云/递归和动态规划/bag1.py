'''
已知一个背包最多能容纳物体的体积为V
现有n个物品第i个物品的体积为vi
第i个物品的重量为wi
求当前背包最多能装多大重量的物品
例如：10,2,[[1,3],[10,4]] --》 4
第一个物品的体积为1，重量为3，第二个物品的体积为10，重量为4。只取第二个物品可以达到最优方案，取物重量为4 
dp[i][j]表示：对于前i个物品，当前背包的容量为j时，这种情况下可以装下的最大价值是dp[i][j]。
如果你没有把这第i个物品装入背包，那么很显然，最大价值dp[i][j]应该等于dp[i-1][j]。你不装嘛，那就继承之前的结果。

如果你把这第i个物品装入了背包，那么dp[i][j]应该等于dp[i-1] [ j-vm[j-vm[i-1][0] ] + vm[i-1][1]。但还是需要和不装入进行大小比较，取价值最大的。
'''
class Solution:
    def knapsack(self , V , n , vw ):
        if V == 0 or n == 0 or not vw:
            return 0
        # dp[i][j]表示：对于前i个物品，当前背包的容量为j时，这种情况下可以装下的最大价值是dp[i][j]
        dp = [[0 for _ in range(V+1)]for _ in range(n+1)]
        
        for i in range(1, n+1):
            for j in range(1, V+1):
                # 如果不拿第i件 最大价值dp[i][j]应该等于dp[i-1][j]。你不装嘛，那就继承之前的结果。
                if j < vw[i-1][0]:
                    dp[i][j] = dp[i-1][j]
                # 拿第i件 那么dp[i][j]应该等于dp[i-1][j-vw[i-1][0]] + vm[i-1][1]。但还是需要和不装入进行大小比较，取价值最大的。
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-vw[i-1][0]] + vw[i-1][1])

        return dp[n][V]

